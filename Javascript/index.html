<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title></title>

    <!--<link rel="stylesheet" href="~/Content/Style/stylesheet.css" />-->

    <script src="scripts/jquery-1.11.3.min.js"></script>
    <script src="scripts/knockout-3.3.0.js"></script>
    <script src="scripts/bluebird.min.js"></script>
	<script type="text/javascript">
		var TRANSMIT_TIME = 1000;
		var TRANSMIT_HUMAN_READ_TIME = 500;
	</script>

	<style>
		
		.container{
			position: absolute; 
			top: 0px; 
			right: 0px; 
			bottom: 0px; 
			left: 0px; 
		}

		.node{
			position: absolute; 
			border: 2px solid gray;
		}
		.node.node-status-online{
			border: 2px solid green;
		}
		.node.node-status-offline{
			border: 2px solid red;
		}
		.node-name{
			background-color: #eeeeee;
			font-size: 95%;
			padding: .25em;
			border-bottom: 1px solid #AAAAAA;
		}

		.node-queue{
			margin: .5em;
		}

		.node-storage{
			margin: .5em;
		}
		.node-storage-slot{
			border: 1px solid #666666;
			padding: 1px 4px;
		}
		.node-storage-slot-empty{
			border: 1px solid #666666;
			font-style: italic;
			color: #bbbbbb;
			text-align: center;
		}

		.message{
			border: 1px solid #AAAAAA;
			padding: .25em;
			background-color: #ddffdd;
		}

		.log{
			border: 1px solid #eeeecc;
			background-color: #ffffdd;
			padding: .5em;

			position: absolute;
			top: 20px;
			left: 20px;
			bottom: 20px;
			width: 500px;

			text-overflow: auto;
		}
	</style>
</head>
<body>
<div class="container">
	<div class="log" data-bind="foreach: logContents">
		<div data-bind="text: $data"></div>
	</div>

	<!-- ko foreach: nodes -->
	<div class="node" data-bind="style: { top: display.y() + 'px', left: display.x() + 'px' }, css: { 'node-status-online': status() == 'online', 'node-status-offline': status() == 'offline' }">
		<div class="node-name" data-bind="text: display.description"></div>
		<div class="node-queue">
			Action:
			<!-- ko if: display.incomingValueAction -->
			<div data-bind="text: display.incomingValueAction" class="node-storage-slot"></div>
			<!-- /ko -->
			<div data-bind="ifnot: display.incomingValueAction, visible: display.incomingValueAction() == null" class="node-storage-slot-empty">n/a</div>
		</div>
		<div class="node-storage">
			Storage:
			<!-- ko foreach: storage -->
			<div data-bind="text: display.description" class="node-storage-slot"></div>
			<!-- /ko -->
			<div data-bind="if: storage().length == 0, visible: storage().length == 0" class="node-storage-slot-empty">empty</div>
		</div>
	</div>
	<!-- /ko -->

	<div data-bind="foreach: messages">
		<div data-bind="text: display.description, deliverMessage: $data" class="message" style="position: absolute;"></div>
	</div>

</div>
</body>
<script type="text/javascript">

ko.bindingHandlers.deliverMessage = {
    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
		if(valueAccessor().display.startX() != null){
			$(element).css({ 'left': valueAccessor().display.startX() + 'px' });
		}

		if(valueAccessor().display.startY() != null){
			$(element).css({ 'top': valueAccessor().display.startY() + 'px' });
		}

		$(element).stop();
		var animation = { left: valueAccessor().display.x() + 'px', top: valueAccessor().display.y() + 'px' }
		$(element).animate(animation, valueAccessor().display.time(), null, valueAccessor().display.delivered);
   }
};

function ViewModel(numberOfStartingNodes){
	var self = this;
	
	self.nodes = ko.observableArray([]);
	self.pipes = ko.observableArray([]);
	self.messages = ko.observableArray([]);
	self.outgoingMessages = ko.observableArray([]);

	self.logContents = ko.observableArray([]);
	self.log = function(logMessage){
		self.logContents.unshift(logMessage);
	};
	
	for(var i = 0; i < numberOfStartingNodes; i++){
		self.nodes.push(new Node(String.fromCharCode(65 + i)));
	}

	self.deliverMessage = function(message, node){
		self.log(message.display.description + ' sent to node ' + node.name);
		
		return new Promise(function(resolve){
			message.display.x(node.display.x() - 100); 
			message.display.y(node.display.y()); // add offset for number of outstanding messages to process?
			message.display.time(TRANSMIT_TIME);
			message.display.delivered = resolve;
			// begin delivery animation
			self.messages.push(message);
		})
		.delay(TRANSMIT_HUMAN_READ_TIME)
		.then(function(){
			self.messages.remove(message);
			return node.processNewMessage(message);
		})
		.delay(TRANSMIT_HUMAN_READ_TIME)
		.then(function(messageResponse){
			return self.deliverMessageResponse(messageResponse, node);
		});
	};

	self.deliverMessageResponse = function(response, node){
		return new Promise(function(resolve){
			response.display.startX(node.display.x() - 100); 
			response.display.startY(node.display.y());
			response.display.x(0); 
			response.display.y(0);
			response.display.time(TRANSMIT_TIME);
			response.display.delivered = resolve;
			// begin delivery
			self.messages.push(response);
		})
		.then(function(){
			if(response.payload != null){
				self.log(response.message.display.description + ' response from node ' + node.name + ': ' + response.status + ' [' + response.payload + ']');
			}
			else{
				self.log(response.message.display.description + ' response from node ' + node.name + ': ' + response.status);
			}
			
			self.messages.remove(response);
		});
	}

	self.refreshNodeLayout = function(){
		var verticalScreenOffset = -50;	// bump everything up 50px

		var height = $(window).height();
		var width = $(window).width();

		// center point of circle
		var centerX = width/2;
		var centerY = height/2;

		// radius of circle
		var radius = 0;
		if(width < height){
			radius = width/2 * .80;
		}
		else{
			radius = height/2 * .80;
		}

		// invert radius to flip circle
		radius = -1 * radius;

		// degrees between items
		var numPoints = self.nodes().length;
		var step = (Math.PI * 2) / numPoints

		// now position them equidistantly around the circle
		for(var i = 0; i < self.nodes().length; i++){
			var node = self.nodes()[i];
			node.display.x( centerX + radius * Math.sin(step * i) );
			node.display.y( centerY + radius * Math.cos(step * i) + verticalScreenOffset );
		}		
	};
	self.refreshNodeLayout();
}

function Node(name){
	var self = this;
	self.name = name;
	self.status = ko.observable();

	self.storage = ko.observableArray([]);

	self.display = {
		x: ko.observable(),
		y: ko.observable(),
		incomingValueAction: ko.observable()
	};
	self.display.description = ko.computed(function(){
		return self.name + ' (' + Math.round(self.display.x()) + ',' + Math.round(self.display.y()) + ')';
	});

	self.processNewMessage = function(message){
		return new Promise(function(resolve){
			self.display.incomingValueAction(message.type + ' ' + message.payload);
			if(message.type == messageTypes.Write){
				var storedData = self.storeData(message.payload);
				self.display.incomingValueAction(message.type + ' ' + storedData.key + ': 200 OK');
				resolve(new MessageResponse(message, "200 OK"));
			}
			else if(message.type == messageTypes.Read){
				var storedData = self.getFromStorage(message.payload);
				if(storedData == null){
					self.display.incomingValueAction(message.type + ' ' + message.payload + ': 404 Not Found');
					resolve(new MessageResponse(message, "404 Not Found"));
				}
				else{
					self.display.incomingValueAction(message.type + ' ' + message.payload + ': 200 OK');
					resolve(new MessageResponse(message, "200 OK", storedData.value));
				}
			}
			else{
				self.display.incomingValueAction(message.type + ': 500 ERROR');
				resolve(new MessageResponse(message, "500 ERROR"));
			}
		});
	};

	self.storeData = function(rawData){
		var data = rawData.split(':');
		var key = data[0];
		var value = null;
		if(data.length > 1){
			value = data[1];
		}
		var storedData = new StoredData(key, value);
		self.storage.push(storedData);
		return storedData;
	};

	self.getFromStorage = function(key){
		var data = self.storage().filter(function(item){
			return item.key == key;
		});
		if(data.length > 0)
			return data[0];
		else
			return null;
	}
}

function StoredData(key, value){
	this.key = key;
	this.value = value;

	this.display = {
		description: key + ":" + value
	};
}

function Pipe(name, nodeFrom, nodeTo){
	this.name = name;
	this.nodeFrom = nodeFrom;
	this.nodeTo = nodeTo;

	this.values = ko.observableArray([]);
}

function Message(name, messageType, payload){
	var self = this;
	self.name = name;
	self.type = messageType;
	self.payload = payload;

	self.display = {
		startX: ko.observable(200),
		startY: ko.observable(0),
		x: ko.observable(0),
		y: ko.observable(0),
		time: ko.observable(1000),
		delivered: function(){}
	};
	if(self.type == messageTypes.Write)
		self.display.description = self.name + ' (' + self.type[0] + ' ' + payload + ')';
	else if(self.type == messageTypes.Read)
		self.display.description = self.name + ' (' + self.type[0] + ' ' + payload + ')';
	else
		self.display.description = self.name + ' (' + self.type[0] + ')';
		

}

function MessageResponse(message, status, payload){
	var self = this;

	self.message = message;
	self.status = status;
	self.payload = payload;

	self.display = {
		startX: ko.observable(0),
		startY: ko.observable(0),
		x: ko.observable(200),
		y: ko.observable(0),
		time: ko.observable(1000),
		delivered: function(){}
	};
	if(self.payload != null)
		self.display.description = self.message.name + "(" + status + ") " + payload;
	else
		self.display.description = self.message.name + "(" + status + ")";

}

var messageTypes = {
	'Write': 'Write',
	'Read': 'Read'
};

var vm = new ViewModel(3);
ko.applyBindings(vm);

var script = [
	new Message("M0", messageTypes.Write, "D0:data 0"),
	new Message("M1", messageTypes.Write, "D1:data 1"),
	new Message("M2", messageTypes.Write, "D2:data 2"),
	new Message("M3", messageTypes.Write, "D3:data 3"),
	new Message("M4", messageTypes.Read, "D3"),
	new Message("M5", messageTypes.Read, "D3"),
	new Message("M6", messageTypes.Write, "D4:data 4"),
	new Message("M7", messageTypes.Write, "D5:data 5"),
	new Message("M8", messageTypes.Read, "D3"),
	new Message("M9", messageTypes.Read, "D5")
];

function processNextMessage(){
	var message = script.shift();

	var randomNode = Math.floor(Math.random() * vm.nodes().length);
	vm.deliverMessage(message, vm.nodes()[randomNode]).then(function(){
		if(script.length > 0)
			setTimeout(processNextMessage, 500);	
	});
}
processNextMessage();


</script>
</html>
