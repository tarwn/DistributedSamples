<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title></title>

	<link rel="stylesheet" href="content/stylesheet.css" />

    <script src="scripts/lib/require-2.1.20.min.js"></script>
    <script src="scripts/main.js"></script>
</head>
<body>
<div class="container">
	<input type="button" value="pause" data-bind="click: pause, enabled: isRunning" />

	<div class="log" data-bind="foreach: logContents">
		<div data-bind="text: $data"></div>
	</div>

	<!-- ko foreach: network.nodes -->
	<div class="node" data-bind="style: { top: display.y() + 'px', left: display.x() + 'px' }, css: { 'node-status-online': status() == 'online', 'node-status-offline': status() == 'offline' }">
		<div class="node-name" data-bind="text: display.description"></div>
		<div class="node-queue">
			Action:
			<!-- ko if: display.incomingValueAction -->
			<div data-bind="text: display.incomingValueAction" class="node-storage-slot"></div>
			<!-- /ko -->
			<div data-bind="ifnot: display.incomingValueAction, visible: display.incomingValueAction() == null" class="node-storage-slot-empty">n/a</div>
		</div>
		<div class="node-storage">
			Storage:
			<!-- ko foreach: storage -->
			<div data-bind="text: display.description" class="node-storage-slot"></div>
			<!-- /ko -->
			<div data-bind="if: storage().length == 0, visible: storage().length == 0" class="node-storage-slot-empty">empty</div>
		</div>
	</div>
	<!-- /ko -->

	<!-- ko foreach: network.messages -->
		<div data-bind="text: display.description, deliverMessage: $data" class="message" style="position: absolute;"></div>
	<!-- /ko -->

</div>
</body>
<script type="text/javascript">

require(["knockout",
		 "app/Constants",
		 "app/ViewModel",
		 "app/Node",
		 "app/Message",
		 "app/MessageResponse",
		 "app/StoredData" ],
function(ko,
		 CONST,
		 ViewModel,
		 Node,
		 Message,
		 MessageResponse,
		 StoredData){
	
//	var vm = new ViewModel(3, CONST.NETWORK_STYLE.Any);
	var vm = new ViewModel(3, CONST.NETWORK_STYLE.NetworkSelectedHead);
	ko.applyBindings(vm);

	var potentialDataValues = {
		"D0": [],
		"D1": [],
		"D2": [],
		"D3": [],
		"D4": [],
		"D5": [],
		"D6": [],
		"D7": []
	};
	var msgCount = 0;

	function generateMessage() {
		if(!vm.isRunning())
			return;

		var randomDataKeyIndex = Math.floor(Math.random() * Object.keys(potentialDataValues).length);
		var randomDataKey = Object.keys(potentialDataValues)[randomDataKeyIndex];
		var operationType = (Math.random() < .5) ? CONST.MESSAGE_TYPES.Read : CONST.MESSAGE_TYPES.Write;
		
		if(operationType == CONST.MESSAGE_TYPES.Write){
			var newValue = "" + Math.floor(Math.random() * 500);
			potentialDataValues[randomDataKey].unshift(newValue);

			var message = new Message("M" + msgCount, CONST.MESSAGE_TYPES.Write, randomDataKey + ":" + newValue);
			vm.network.deliverExternalMessage(message).then(function(response){
				var result = evaluateWriteResponse(randomDataKey, response);
				console.log(result.text);
				setTimeout(generateMessage, 500);	
			});
		}
		else{
			// if no value has been stored anywhere yet, try another random message/target
			if(potentialDataValues[randomDataKey].length == 0){
				generateMessage();
				return;
			}

			var message = new Message("M" + msgCount, CONST.MESSAGE_TYPES.Read, randomDataKey);
			vm.network.deliverExternalMessage(message).then(function(response){
				var result = evaluateReadResponse(randomDataKey, response);
				console.log(result.text);
				setTimeout(generateMessage, 500);	
			});			
		}
	}

	function evaluateWriteResponse(dataKey, response){
		return {
			meetsExpectations: true,
			text: "Store " + response.message.payload + " -> " + response.status
		};
	}

	function evaluateReadResponse(dataKey, response){
		if(response.status == "200 OK"){
			var historyNumber = potentialDataValues[dataKey].indexOf(response.payload);
			if(historyNumber == -1){
				return {
					meetsExpectations: true,
					text: "Retrieve " + response.message.payload + " -> " + response.status + " :: Received Invalid Value => " + response.payload
				};
			}
			else if(historyNumber == 0) {
				return {
					meetsExpectations: true,
					text: "Retrieve " + response.message.payload + " -> " + response.status + " :: Received Current => " + response.payload
				};
			}
			else {
				return {
					meetsExpectations: true,
					text: "Retrieve " + response.message.payload + " -> " + response.status + " :: Received " + historyNumber + " Out Of Date => " + response.payload
				};
			}
		}
		else{
			return {
				meetsExpectations: false,
				text: "Retrieve " + response.message.payload + " -> " + response.status
			};
		}
	}

	generateMessage();
});

</script>
</html>
